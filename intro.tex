

% \chaya{notes: begin}
% There exist several approaches to make current zkSNARKs adequate for real-life deployment among which are \emph{simulation extractability} (SE) and \emph{updatability}.
% There are zkSNARKs that are SE and zkSNARKs that are updatable universal. The question of zkSNARKs that enjoy both of these properties was recently tackled by Kohlweiss and Zajac~\cite{KZ21}
% where they consider SE for \emph{universal srs} SNARKs. However, their definition does not capture the updatability property. Intuitively, the updatability of the srs allows an adversarial prover to contribute to updating, and see proofs with respect to different updated srs'es before attempting to provide a proof for a false statement (potentially output a proof wrt a srs that is different from the srs'es corresponding to all the simulated proofs seen). This capability of the adversary is not modeled in the definition of~\cite{KZ21}. In this work, we capture this by extending the definition of SE for updatable SNARKs and investigate whether existing zkSNARK constructions satisfy the new definition.
%
%
% Points to mention:
% \begin{itemize}
%     \item cite Abdolmaleki et
% al.~\cite{CCS:AbdRamSla20}:
%     \begin{itemize}
%         \item the most relevant related work
%         \item was published at CCS20 (so gives credibility to our result)
%         \item they show a generic compiler/lifting techniques for
% non-black-box simulation extractability
%         \item they also preserve succinctness of the
% argument.
%     \end{itemize}
%     \item non-malleability is usually handeled by binding signatures e.g. Zerocash, Zcash, Orchard.
%     \item Working on improving the security definitions to capture real-world scenarios and powerful adversaries is an important step and makes SNARKs easier to reason about.
%
%     \item Classical definition of KS is not enough in applications:
%     More generaly, the classical definition of KS seems to be unsatisfactory in applications, as it does not provide sufficient security guarantees for SNARKs in the following sense:
%     The natural belief that seeing a valid proof only tells a verifier that the prover knew a satisfactory witness is simply not true. In the context of malleable SNARKs, seeing other valid proofs allows one to construct related proofs   whithout knowing any witness.
%     \item Allowing for malleability makes it difficult to reason about the security properties of SNARKs. Ignoring the ability of an adversary to see other valid proofs prevents from modeling a realistic definition.
%     \item Generic lifting techniques / compilers have overheads and are unnecessary to be applied to schemes for which we can directly show they satisfy our definitions.
%
% \end{itemize}
%
% \chaya{notes:end}


\section{Introduction}
Zero-knowledge proof systems that allow a prover to convince a verifier of a statement without revealing anything beyond the truth of the statement have applications in cryptography and the theory of computation~\cite{FOCS:GolMicWig86,STOC:Fortnow87,C:BGGHKMR88}.
When restricted to computationally sound proofs, called \emph{argument systems}, proof length can be shorter than the length of the witness~\cite{brassbard1988minimum}.
Zero-knowledge Succinct Non-interactive ARguments of Knowledge (zkSNARKs) are zero-knowledge argument systems that additionally have a succinctness property -- small proof sizes and fast verification. 
Since their introduction in~\cite{micali1994cs}, zk-SNARKs have been a powerful and versatile design tool for secure cryptographic protocols. They became particularly relevant for blockchain applications that demand short proofs and fast verification, such as privacy-preserving cryptocurrencies~\cite{SP:BCGGMT14} in Zcash and scalable and private smart contracts in Ethereum\footnote{\url{https://z.cash/},\url{https://ethereum.org}}.

The work of~\cite{EC:GGPR13} proposed a preprocessing zk-SNARK for general NP statements phrased in the language of Quadratic Span Programs (QSP) and Quadratic Arithmetic Programs (QAP) for Boolean and arithmetic circuits respectively. This built on previous works of~\cite{IKO07,AC:Groth10a,TCC:Lipmaa12} and led to several works~\cite{TCC:BCIOP13,SP:PHGR13,C:BCGTV13,AC:Lipmaa13,USENIX:BCTV14,EC:Groth16} with very short proof sizes and fast verification. 
The line of work on pre-processing zkSNARKs has seen rapid progress with many works proposing significant improvements in efficiency of different parameters like proof size, verifier efficiency, complexity of setup etc.
Most modern zkSNARK constructions follow a modular blueprint that involves the design of an information theoretic interactive protocol, e.g. an Interactive Oracle Proof (IOP), that is then compiled via cryptographic tools to obtain an interactive argument system.  This is then turned into a zkSNARK using the Fiat-Shamir transformation in the Random Oracle Model (ROM).
In particular, several schemes such as
$\sonic$~\cite{CCS:MBKM19}, $\plonk$~\cite{EPRINT:GabWilCio19}, and $\textsf{Marlin}$~\cite{EC:CHMMVW20}
follow this approach where the information theoretic object is an algebraic variant of IOP, and the cryptographic primitive in the compiler is a polynomial commitment scheme (PC).  

\paragraph{Simulation extractability.}

Most zkSNARKs are shown to satisfy a standard knowledge soundness property. Intuitively, this guarantees that
a prover that creates a valid proof knew a valid witness. However, deployments of zkSNARKs in real-world applications require a stronger property -- \textit{simulation-extractability} (SE). 
This is because, in practice, an adversary against the zkSNARK has access to proofs provided by other parties using the same
zkSNARK. The definition of knowledge soundness ignores the ability of an adversary to see other valid proofs that may occur in real-world applications.  For instance, in applications of
zkSNARKs in privacy-preserving blockchains, proofs are posted on the chain for all
blockchain-participants to see. Therefore, it is necessary for a zero-knowledge proof system to be \emph{non-malleable}, that is, resilient against adversaries that additionally get to see proofs generated by different parties before trying to forge.
Therefore, it is necessary for a zero-knowledge proof system to be \emph{simulation-extractable}, that is, resilient against adversaries that additionally get to see proofs generated by different parties before trying to forge.
This captures the more general scenario where an adversary against the zkSNARK has access to proofs provided by other parties as it is in applications of zkSNARKs in privacy-preserving blockchains, where proofs are posted on the chain for all
participants in the network to verify. 

\paragraph{zkSNARKs in the updatable setting.}
One of the downsides of efficient zkSNARKs like~\cite{AC:Groth10a,TCC:Lipmaa12,EC:GGPR13,SP:PHGR13,AC:Lipmaa13,AC:DFGK14,EC:Groth16} is that they rely on a \textit{trusted setup}, where there is a structured reference string (SRS) that is assumed to be generated by a trusted party. In practice, however, this assumption is not well founded; if the party that generates the SRS is not honest, then they can produce proofs of false statement. That is, if the trusted setup assumption does not hold, knowledge soundness breaks down.
Groth et al~\cite{C:GKMMM18} propose a setting to tackle this challenge which allows parties -- provers and verifiers -- to \emph{update} the SRS, that is, take a current SRS and contribute to it randomness in a verifiable way to obtain a new SRS. The guarantee in this \textit{updatable setting} is that knowledge soundness holds as long as one of the parties who updates the SRS is honest. The SRS is also \emph{universal}, in that it does not depend on the relation to be proved but only an upper bound on the size of the statements.
Although inefficient, as the SRS length is quadratic to the size of the statement,~\cite{C:GKMMM18} set a new
paradigm of universal updatable setting for designing zkSNARKs.

The first universal zkSNARK with updatable and linear size SRS was
$\sonic$ proposed by Maller et al.~in \cite{CCS:MBKM19}. Subsequently, Gabizon et
al.~designed $\plonk$~\cite{EPRINT:GabWilCio19} which currently is the
most efficient updatable universal zkSNARK. Independently, Chiesa et
al.~\cite{EC:CHMMVW20} proposed $\textsf{Marlin}$ with comparable efficiency to
$\plonk$.

\paragraph{The challenge of SE in the updatable setting.}

The notion of simulation-extractability for zkSNARKs which is well motivated in practice has not been studied in this updatable setting. 
Consider the following scenario: an instance proof pair with respect to some SRS is available for public verification, $(\srs,x,\pi)$. Now, if there is a new purported proof $(\srs',x,\pi')$ with respect to an updated $\srs'$, we would like the guarantee that the prover must have known a witness corresponding to $x$, and therefore computed $\pi'$. Since everybody is allowed to update an SRS, the ability for an adversary to perform an update $\srs$ to $\srs'$, and ``move" the proof $\pi$ from the old SRS to a proof $\pi'$ for the new SRS without knowing a witness clearly violates security. That is, even an adversary who knows the trapdoor for the update from $\srs$ to $\srs'$ should not be able to break SE as long as there was at least one honest update to $\srs$.

As it turns out, defining SE for updatable SRS zkSNARKs requires some care. 
Since the SRS is being continually updated, there are proofs with respect to \textit{different} SRSs available for the adversary to see before attempting to forge a proof with respect to a current SRS. 
That is, each SRS in the update chain spawns a simulation oracle. Intuitively, the updatability of the SRS allows an adversarial prover to contribute to updating, and see proofs with respect to different updated SRSs before attempting to provide a proof for a false statement (potentially output a proof wrt a SRS that is different from the SRSs corresponding to all the simulated proofs seen). A definition of SE in the updatable setting should take into account this additional power of the adversary, which is not captured by existing definitions of SE. 
While generic lifting techniques/compilers~\cite{EPRINT:KZMQCP15,CCS:AbdRamSla20} can be applied to updatable SRS SNARKs to obtain SE, not only do they inevitably incur overheads and lead to efficiency loss, we contend that the standard definition of SE does not suffice in the updatable setting.


\paragraph{Fiat--Shamir.}
The Fiat--Shamir (FS) transform takes a public-coin interactive protocol and
makes it interactive by hashing the current protocol transcript to compute the
verifier's public coins. While in principle justifiable in the random oracle
model (ROM)~\cite{CCS:BelRog93}, it is theoretically
unsound~\cite{FOCS:GolKal03} and so only a heuristic that should be used with
care.
%
The FS transform is a now popular design tool in constructing
zkSNARKs. In the updatable universal SRS setting, works like \sonic{}~\cite{CCS:MBKM19}
\plonk{}~\cite{EPRINT:GabWilCio19}, and \marlin~\cite{EC:CHMMVW20} are designed
and proven secure as multi-round interactive protocols. Security is then only
\emph{conjectured} for their non-interactive variants by employing the FS
transform.

We investigate the non-malleability properties of a class of zkSNARK protocols obtained by FS-compiling multi-round protocols in the updatable SRS setting and give a modular approach to analyze non-malleablilty of zkSNARKs.

\subsection{Our Contributions}
\begin{itemize}
\item 
\emph{Updatable simulation extractability (USE)}. 
We propose a definition of simulation extractability in the updatable SRS setting called USE, that captures the additional power the adversary gets by having access to updating the SRS and seeing proofs with respect to different SRSs.
    
\item 
\emph{General theorem for USE of FS-compiled interactive protocols.}
We then show that a class of interactive proofs of knowledge that are honest-verifier zero-knowledge,
have a unique response property, and satify a property we define called forking soundness \emph{are USE out-of-the box} in the random oracle model when the Fiat--Shamir transformation is applied to them. 
Informally, our notion of forking soundness is a variant of special soundness where the transcripts provided to the extractor are
obtained through interaction with an honest verifier, and the extraction guarantee is computational instead of unconditional. 
Our extractor only needs oracle access to the adversary, it does not depend on the adversaryâ€™s code, nor relies on knowledge
assumptions.
    
\item
\emph{USE for concrete zkSNARKs.}
We then prove that the most efficient updatable SRS SNARKS -- Plonk/Sonic/Marlin -- satisfy the notions necessary to invoke our general theorem, thus showing that these zkSNARKs are updatable simulation extractable.
Proving that these protocols satisfy the required properties is done in the algebraic group model (AGM).
	
%\item
%We make several technical contributions along the way. Our generalized forking lemma is of independent interest.
\end{itemize}



\subsection{Technical Overview}
%unique response, forking soundness. general theorem without additional assumptions. to apply the theorem to concrete schemes like plonk, we show it satisfies unique response, forking soundness, in AGM.

The proof of our general theorem for USE is, at a high level, along the lines of the proof of SE for FS-compiled sigma protocol
from~\cite{INDOCRYPT:FKMV12}. However, we need new and stronger notions as we consider proof systems that are
richer than simple sigma protocols. We discuss some of the technical challenges below.

\plonk~\cite{EPRINT:GabWilCio19} and \sonic~\cite{CCS:MBKM19} were originally presented
as interactive proofs of knowledge that are made non-interactive by the Fiat--Shamir transform. In the following,
we denote the underlying interactive protocols by $\plonkprot$ (for $\plonk$)
and $\sonicprot$ (for $\sonic$) and the resulting non-interactive proof systems by
$\plonkprotfs$ and $\sonicprotfs$, respectively.

\oursubsub{Forking soundness.} 
Following~\cite{INDOCRYPT:FKMV12}, one would have to show that for the protocols we consider, a witness can be extracted from sufficiently many valid transcripts with a common prefix. However, many protocols
do not meet the standard definition of special soundness for sigma protocols, that requires extraction of a witness from any two transcripts, with the same first message. We put forth a notion analogous to special soundness, that is more general and applicable to a wider class of protocols -- protocols that are more than three rounds, and rely on an SRS. For $\plonkprot$ and
$\sonicprot$ that are not three move protocols, the definition needs to be adapted. Furthermore, the number of transcripts
required for extraction is more than two. Concretely, $(3 \noofc + 1)$---where $\noofc$ is the
number of constraints in the proven circuit---for $\plonkprot$ and
$(\multconstr + \linconstr + 1)$---where $\multconstr$ and $\linconstr$ are the
numbers of multiplicative and linear constraints---for $\sonicprot$. Hence, we
do not have a pair of transcripts, but a \emph{tree of transcripts}.

In protocols that rely on SRS that come with a
trapdoors, an adversary in posession of the trapdoor can produce multiple
valid proof transcripts without knowing the witness and potentially for false
statements. This is true even in the updatable setting, where there exists a trapdoor for any updated SRS.
Recall that the standard special soundness definition requires
witness extraction from \emph{any} tree of acceptable transcripts that share a
common root. This means that there are no such trees for false
statements. We define a different, forking lemma-related, version
of soundness that we call \emph{forking soundness}. Forking soundness guarantees that it is
possible to extract a witness from all (but negligibly many) trees of accepting
transcripts produced by probabilistic polynomial time (PPT) adversaries, given
that the trees are generated as interactions between a (possibly malicious)
prover and an honest verifier. That is, if extraction from such a tree fails, then we break an
underlying computational assumption.

\oursubsub{Unique response property.} 
Another property required to show USE is the unique response property~\cite{C:Fischlin05} which
says that for $3$-messages sigma
protocols, all but the first message sent by the prover are
deterministic (intuitively, the prover can only employ fresh randomness in the
first message of the protocol). We cannot use this definition as is since the protocols we consider have other rounds where the prover messages are randomized. In $\plonkprotfs$, both the first and the second prover's messages are randomized. Although $\sonicprot$ prover is deterministic after it picks its first message, the protocol has more than $3$ rounds. We propose a generalisation of the
definition which states that a protocol is $\ur{i}$ if the prover is
deterministic starting from its $(i + 1)$-th message. For our proof it is
sufficient that this property is met by $\plonkprot$ for $i = 2$. Since
\sonic{}'s prover is deterministic from the second message on, it is $\ur{1}$.


\oursubsub{HVZK.}  In order to invoke our main theorem on $\plonkprotfs$ and
$\sonicprotfs$ to conclude USE, we also need to show that (interactive)
$\plonkprot$ and $\sonicprot$ are HVZK in the standard model. Although both
$\sonic$ and $\plonk$ are zero-knowledge, their simulators utilize
trapdoors. However, for our reduction, we need simulators that rely only on
reordering the messages and picking suitable verifier challenges, without
knowing the SRS trapdoor.  That is, any PPT party should be able to produce a
simulated proof by its own in a trapdoor-less wat. (Note that this property does
not necessary break soundness of the protocol as the simulator is required only
to produce a transcript and is not involved in a real conversation with a real
verifier). We show simulators for $\plonkprotfs$ and $\sonicprotfs$ that rely
only on the programmability of the RO, where programmability is only needed from
some round $i$ onwards.  \chaya{revisit this. is HVZK for the interactive
  protocol? then why programming? it might be a good idea to elaborate on why a
  trapdoor-based simulator does not work in the reduction. I am not sure I have
  clarity on this.}
\michals{16.09}{maybe we should just define Trapdoor-less simulatable (TLS) protocols?}

\oursubsub{Generalisation of the general forking lemma.} 
Consider an interactive $3$-message special-sound protocol $\ps$ and its
non-interactive version $\ps_\fs$ obtained by the Fiat--Shamir transform. The
general forking lemma provides an instrumental lower bound for the probability
of extracting a witness from an adversary who provides two proofs for the same
statement that share the first message. Since $\plonkprot$ and $\sonicprot$ have
more than $3$ messages and are not special-sound, the forking lemma of Bellare
and Neven~\cite{CCS:BelNev06}, cannot be used directly. We propose a
generalization that covers multi-message protocols where witness extraction
requires more transcripts than merely two.  Unfortunately, we also observe that
the security gap grows with the number of transcripts and the probability that
the extractor succeeds diminishes significantly; the security loss, albeit big, is polynomial.

Most modern zkSNARKs~\cite{SP:BBBPWM18,CCS:MBKM19} heavily
rely on the Fiat--Shamir transform and thus potentially the forking lemma. First, an interactive
protocol is proposed and its security and forking soundness analysed. Second,
one uses an argument that the Fiat--Shamir transform can be used to get a
protocol that is non-interactive and shares the same security properties.

We see our generalized forking lemma as contributing to a critical assessment of
this approach. The analysis of the interactive protocol is not enough and one
has to consider the security loss implied by the Fiat-Shamir transform for the target security notion. Thus one has to either rely on our generalisation of the forking
lemma or disclose a transformation that does not suffer this loss. We note that
the security loss may also apply when knowledge soundness is proven. That is the
case for the original $\sonic$ paper, whose security proof relies on so-called witness-extended
emulation. The authors of $\plonk$ and recent work on $\sonic$~\cite{cryptoeprint:2020:1351} work around this problem by proving
knowledge soundness directly in the AGM.



\subsection{Related Work}
%-- notes 
% In contrast to Faust et
% al.~\cite{INDOCRYPT:FKMV12} who focused on special-sound $3$-message sigma
% protocols, our result can be applied to a wider class of protocols and is
% applicable to zkSNARKs.
%
%
% GT20: also about security loss incurred by FS transformation for KS from WEE. put forth a notion of state restoration. analysis in AGM.
% Here: not just KS, but SE. we minimize AGM, rely on rewinding. directly capture the ``state restoration" capability of the prover in the forking lemma.
% no online extraction. new technical challenges arise.

\ourpar{Simulation extractability.}
There are many results on simulation extractability for
non-interactive zero-knowledge proofs (NIZKs). First, Groth \cite{AC:Groth07}
noticed that a (black-box) SE NIZK is
universally-composable (UC)~\cite{EPRINT:Canetti00}. Then Dodis et al.~\cite{AC:DHLW10} introduced a
notion of (black-box) \emph{true simulation extractability} and showed that no
NIZK can be UC-secure if it does not have this property. 

In the context of zkSNARKs, the first
SE zkSNARK was proposed by Groth and Maller~\cite{C:GroMal17} and SE
zkSNARK for QAP by Lipmaa~\cite{EPRINT:Lipmaa19a}. 
Kosba's et
al.~\cite{EPRINT:KZMQCP15} give a general transformation from a NIZK to a
black-box SE NIZK. Although their transformation works for zkSNARKs as well,
succinctness of the proof system is not preserved by the transformation.
Recently, Abdolmaleki et al.~\cite{CCS:AbdRamSla20} showed another transformation that
obtains non-black-box simulation extractability but also preserves
succinctness of the argument. 
The zkSNARK of~\cite{EC:Groth16} has been shown to be SE by introducing minor modifications to the construction and making
stronger assumptions \cite{EPRINT:BowGab18,EPRINT:AtaBag19}. Recently,~\cite{EPRINT:BKSV20} showed that the
original Groth's proof system from~\cite{EC:Groth16} is weakly SE and
randomizable. None of these results are for zkSNARKs in the updatable SRS setting.

\ourpar{Forking lemma generalizations.}
There are several task specific variants, e.g.,~\cite{INDOCRYPT:HerSae03,CCS:BagCheJar08,AC:BelDaiLi19}, of the general forking lemma~\cite{JC:PoiSte00,CCS:BelNev06} for analyzing the forking behavior of random-oracle based executions.
In~\cite{EC:BCCGP16}, Bootle et al.~proposed a novel inner-product argument which
security relies on, so-called, witness-extended emulation. To show that
property, the authors proposed a new version of forking lemma, which gives a
lower bound on probability that a tree finding algorithm is able to produce a 
tree of acceptable transcripts by rewinding a conversation between a
(potentially malicious) prover and verifier.

Although the result in that paper is dubbed a ``forking lemma'' it
differs from forking lemmas known from e.g.~\cite{JC:PoiSte00,CCS:BelNev06}.
First of all, the forking lemmas in these papers analyse the probability of building
a tree of acceptable transcripts for Fiat--Shamir based non-interactive proof
systems, while the protocol presented by Bootle et al.~is intended to work for
interactive proof systems.

Importantly, it is not obvious how the result of Bootle et al.~can be used to
show security of non-interactive protocols as it relies on interactive provers
whose proving strategies are more limited than proving strategies of
non-interactive provers. For example, if a challenge given by the verifier does not
suit an interactive prover, it can only try to finish a proof with it or
abort. On the other hand, a non-interactive prover has far wider scope of
possible actions--when the protocol is non-interactive the prover may
adapt its strategy based on the random oracle outputs. 
This is reminiscent of \emph{state restoration} security~\cite{TCC:BenChiSpo16,EPRINT:Holmgren19} which is also about the security loss incurred by FS transformation for knowledge soundness from witness extended emulation.

Here, we directly capture the state restoration capability of the prover in the forking lemma instead of defining an interactive game where the prover can rewind the verifier to an earlier state as is done in~\cite{C:GhoTes21}. 
The work of~\cite{C:GhoTes21} further shows that state restoration security gives tight security guarantees for the
non-interactive versions of Bulletproof~\cite{SP:BBBPWM18} and \sonic~. 
Our work differs from~\cite{C:GhoTes21} in the following ways. First, they
focus on showing security of concrete proof systems, while we show
a general theorem about the security of a wide class of protocols. 
Second, they only consider knowledge soundness, while we focus on the stronger notion of simulation extractability. Third, the proof of~\cite{C:GhoTes21} is in the AGM which allows for online extraction, whereas we aim to minimize our reliance on the AGM. In partiular, our main theorem does not rely on AGM and we tackle technical challenges arising from extraction by rewinding. 
However, note that we show that concrete protocols satisfy the preconditions of our main theorem in the AGM.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "plonkext"
%%% End:
