% !TEX root = main.tex
% !TEX spellcheck = en-US

\section{Non-malleability of Plonk} 
\label{sec:plonk}
In this section, we show that $\plonkprotfs$ is simulation-extractable. To this end, we first use the unique opening property to show that
$\plonkprotfs$ has the $\ur{3}$ property,
cf.~\cref{lem:plonkprot_ur}.
Next, we show that $\plonkprotfs$ is rewinding-based knowledge sound. That is, given a number of accepting transcripts whose first $3$ messages match, we can either extract a witness for the proven statement or use one of the transcripts to break the $\udlog$ assumption. This result is shown in the AGM, cf.~\cref{lem:plonkprot_ss}. We then show that $\plonkprotfs$ is $3$-programmable trapdoor-less ZK in the AGM, cf.~\cref{lem:plonk_tlzk}.

Given rewinding-based knowledge soundness, $\ur{3}$ and trapdoor-less zero-knowledge of $\plonkprotfs$, we invoke \cref{thm:se} and conclude that $\plonkprotfs$ is simulation-extractable.

\newcommand{\vql}{\vec{q_{L}}}
\newcommand{\vqr}{\vec{q_{R}}}
\newcommand{\vqm}{\vec{q_{M}}}
\newcommand{\vqo}{\vec{q_{O}}}
\newcommand{\vx}{\vec{x}}
\newcommand{\vqc}{\vec{q_{C}}}

\subsection{Plonk Protocol Description}
\label{sec:plonk_explained}
\oursubsub{The constraint system.}
Assume $\CRKT$ is a fan-in two arithmetic circuit, whose
fan-out is unlimited and has $\numberofconstrains$ gates and $\noofw$ wires
($\numberofconstrains \leq \noofw \leq 2\numberofconstrains$). The constraint
system of $\plonk$ is defined as follows:
\begin{compactitem}
	\item Let $\vec{V} = (\va, \vb, \vc)$, where $\va, \vb, \vc
	\in \range{1}{\noofw}^\numberofconstrains$. Entries $\va_i, \vb_i, \vc_i$ represent indices of left,
	right and output wires of the circuit's $i$-th gate.
	\item Vectors $\vec{Q} = (\vql, \vqr, \vqo, \vqm, \vqc) \in
	(\FF^\numberofconstrains)^5$ are called \emph{selector vectors}:
	\begin{inparaenum}[(a)]
		\item If the $i$-th gate is a multiplication gate then $\vql_i = \vqr_i = 0$,
		$\vqm_i = 1$, and $\vqo_i = -1$. 
		\item If the $i$-th gate is an addition gate then $\vql_i = \vqr_i  = 1$, $\vqm_i =
		0$, and $\vqo_i = -1$. 
		\item $\vqc_i = 0$ for multiplication and addition gates.\footnote{The $\vqc_i$ selector vector is meant to encode (input independent) constants.} 
	\end{inparaenum}
\end{compactitem}

We say that vector $\vx \in \FF^\noofw$ satisfies constraint system if for all $i
\in \range{1}{\numberofconstrains}$
\[
\vql_i \cdot \vx_{\va_i} + \vqr_i \cdot \vx_{\vb_i} + \vqo \cdot \vx_{\vc_i} +
\vqm_i \cdot (\vx_{\va_i} \vx_{\vb_i}) + \vqc_i = 0. 
\]

Public inputs $\brak{\inp_j}_{j = 1}^{\instsize}$ are enforced by adding the constrains
\[ \va_i = j, \vql_i = 1, \vqm_i = \vqr_i = \vqo_i = 0, \vqc_i = -\inp_j\,,
\]
for some $i \in \range{1}{\noofc}$.

\oursubsub{Algorithms rolled out}
\label{sec:plonk_explained}
\plonk{} argument system is universal. That is, it allows to verify computation
of any arithmetic circuit which has up to $\numberofconstrains$
gates using a single SRS. However, to make computation efficient, for each
circuit there is a preprocessing phase which extends the SRS with
circuit-related polynomial evaluations.

For the sake of simplicity of the security reductions presented in this paper, we
include in the SRS only these elements that cannot be computed without knowing
the secret trapdoor $\chi$. The rest of the preprocessed input can
be computed using these SRS elements. We thus let them to be computed by the
prover, verifier, and simulator separately.

\ourpar{$\plonk$ SRS generating algorithm $\kgen(\REL)$:}
The SRS generating algorithm picks at random $\chi \sample \FF_p$, computes
and outputs
\(
\srs = \left(\gone{\smallset{\chi^i}_{i = 0}^{\numberofconstrains + 5}},
\gtwo{\chi} \right).
\)

\ourpar{Preprocessing:}
Let $H = \smallset{\omega^i}_{i = 1}^{\numberofconstrains }$ be a
(multiplicative) $\numberofconstrains$-element subgroup of a field $\FF$
compound of $\numberofconstrains$-th roots of unity in $\FF$. Let $\lag_i(X)$ be
the $i$-th element of an $\numberofconstrains$-elements Lagrange basis. During
the preprocessing phase polynomials $\p{S_{id j}}, \p{S_{\sigma j}}$, for
$\p{j} \in \range{1}{3}$, are computed:
\begin{equation*}
\begin{aligned}
\p{S_{id 1}}(X) & = X,\\[\myskip]
\p{S_{id 2}}(X) & = k_1 \cdot X,\\[\myskip]
\p{S_{id 3}}(X) & = k_2 \cdot X,
\end{aligned}
\qquad
\begin{aligned}
\p{S_{\sigma 1}}(X) & = {\textstyle{\sum_{i = 1}^{\noofc} \sigma(i) \lag_i(X)}},\\[\myskip]
\p{S_{\sigma 2}}(X) & = {\textstyle \sum_{i = 1}^{\noofc}
	\sigma(\noofc + i) \lag_i(X)},\\[\myskip]
\p{S_{\sigma 3}}(X) & ={\textstyle\sum_{i = 1}^{\noofc} \sigma(2 \noofc + i) \lag_i(X)}.
\end{aligned}
\end{equation*}
Coefficients $k_1$, $k_2$ are such that $H, k_1 \cdot H, k_2 \cdot H$ are
different cosets of $\FF^*$, thus they define $3 \cdot \noofc$
different elements. Gabizon et al.~\cite{EPRINT:GabWilCio19} notes that it is enough to set
$k_1$ to a quadratic residue and $k_2$ to a quadratic non-residue.

Furthermore, we define polynomials $\p{q_L}, \p{q_R}, \p{q_O}, \p{q_M}, \p{q_C}$
such that
\begin{equation*}
\begin{aligned}
\p{q_L}(X) & = {\textstyle \sum_{i = 1}^{\noofc}} \vql_i \lag_i(X), \\
\p{q_R}(X) & = \textstyle \sum_{i = 1}^{\noofc} \vqr_i \lag_i(X), \\
\p{q_M}(X) & = \textstyle \sum_{i = 1}^{\noofc} \vqm_i \lag_i(X),
\end{aligned}
\qquad
\begin{aligned}
\p{q_O}(X) & = \textstyle  \sum_{i = 1}^{\noofc} \vqo_i \lag_i(X), \\
\p{q_C}(X) & =  \textstyle \sum_{i = 1}^{\noofc} \vqc_i \lag_i(X). \\
\vphantom{\p{q_M}(X)  = \textstyle \sum_{i = 1}^{\noofc} \vqm_i \lag_i(X),}
\end{aligned}
\end{equation*}

\ourpar{Proving statements in $\plonkprotfs$} We show how prover's algorithm
$\prover(\srs, \inp=\brak{\wit'_i}_{i = 1}^\instsize, \wit = \brak{\wit_i}_{i=1}^{3 \cdot \noofc})$ operates for
the Fiat--Shamir transformed version of Plonk. Note that for notational convenience $\wit$ also contains the public input wires $\wit'_i=\wit_i$, $i\in \range{1}{\ell}$.
\begin{description}
	\item[Message 1] Sample $b_1, \ldots, b_9 \sample \FF_p$; compute
	$\p{a}(X), \p{b}(X), \p{c}(X)$ as
	\begin{align*}
	\p{a}(X) &= (b_1 X + b_2)\p{Z_H}(X) + \textstyle \sum_{i = 1}^{\noofc} \wit_i \lag_i(X) \\
	\p{b}(X) &= (b_3 X + b_4)\p{Z_H}(X) + \textstyle \sum_{i = 1}^{\noofc} \wit_{\noofc + i} \lag_i(X) \\
	\p{c}(X) &= (b_5 X + b_6)\p{Z_H}(X) + \textstyle \sum_{i = 1}^{\noofc} \wit_{2 \cdot \noofc + i} \lag_i(X) 
	\end{align*}
	Output polynomial commitments $\gone{\p{a}(\chi), \p{b}(\chi), \p{c}(\chi)}$.  
	
	\item[Message 2] Compute challenges $\beta, \gamma \in \FF_p$ by querying random oracle
	on partial proof, that is,
	\(
	\beta = \ro(\tzkproof[0..1], 0)\,, \qquad \gamma = \ro(\tzkproof[0..1], 1)\,.
	\)
	
	Compute permutation polynomial $\p{z}(X)$
	\begin{multline*}
	\p{z}(X) = (b_7 X^2 + b_8 X + b_9)\p{Z_H}(X) + \lag_1(X) + \\
	+ \sum_{i = 1}^{\noofc - 1} \left(\lag_{i + 1} (X) \prod_{j = 1}^{i} \frac{
		(\wit_j +\beta \omega^{j - 1} + \gamma)(\wit_{\noofc + j} + \beta k_1
		\omega^{j - 1} + \gamma)(\wit_{2 \noofc + j} +\beta k_2 \omega^{j- 1} +
		\gamma)} {(\wit_j+\sigma(j) \beta + \gamma)(\wit_{\noofc + j} + \sigma(\noofc
		+ j)\beta + \gamma)(\wit_{2 \noofc + j} + \sigma(2 \noofc + j)\beta +
		\gamma)}\right)
	\end{multline*}
	Output polynomial commitment $\gone{\p{z}(\chi)}$
	
	\item[Message 3] Compute the challenge $\alpha = \ro(\tzkproof[0..2])$, compute the quotient
	polynomial
	\begin{align*}
	& \p{t}(X)  = \\
	& (\p{a}(X) \p{b}(X) \selmulti(X) + \p{a}(X) \selleft(X) + 
	\p{b}(X)\selright(X) + \p{c}(X)\seloutput(X) + \pubinppoly(X) + \selconst(X)) /  
	\p{Z_H}(X) +\\
	& + ((\p{a}(X) + \beta X + \gamma) (\p{b}(X) + \beta k_1 X + \gamma)(\p{c}(X) 
	+ \beta k_2 X + \gamma)\p{z}(X)) \infrac{\alpha}{\p{Z_H}(X)} \\
	& - (\p{a}(X) + \beta \p{S_{\sigma 1}}(X) + \gamma)(\p{b}(X) + \beta 
	\p{S_{\sigma 2}}(X) + \gamma)(\p{c}(X) + \beta \p{S_{\sigma 3}}(X) + 
	\gamma)\p{z}(X \omega))  \infrac{\alpha}{\p{Z_H}(X)} \\
	& + (\p{z}(X) - 1) \lag_1(X) \infrac{\alpha^2}{\p{Z_H}(X)}
	\end{align*}
	Split $\p{t}(X)$ into degree less then $\noofc$ polynomials
	$\p{t'_{lo}}(X), \p{t'_{mid}}(X), \p{t'_{hi}}(X)$, such that
	\(
	\p{t}(X) = \p{t_{lo}}(X) + X^{\noofc} \p{t_{mid}}(X) + X^{2 \noofc}
	\p{t_{hi}}(X)\,.
	\)
	Compute $\p{t_{lo}}(X) = \p{t'_{lo}}(X) + b_{10} X^{\noofc}, \p{t_{mid}}(X) = \p{t'_{mid}} - b_{10} + b_{11} X^{\noofc}, \p{t_{hi}}(X) = \p{t'_{hi}}(X) - b_{11}$.
	Output $\gone{\p{t_{lo}}(\chi), \p{t_{mid}}(\chi), \p{t_{hi}}(\chi)}$.
	
	\item[Message 4] Get the challenge $\chz \in \FF_p$, $\chz = \ro(\tzkproof[0..3])$.
	Compute opening evaluations
	\(
	\p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma 2}}(\chz), \p{t}(\chz), \p{z}(\chz \omega),
	\)
	Compute the linearization polynomial
	\[
	\p{r}(X) =
	\begin{aligned}
	& \p{a}(\chz) \p{b}(\chz) \selmulti(X) + \p{a}(\chz) \selleft(X) + \p{b}(\chz) \selright(X) + \p{c}(\chz) \seloutput(X) + \selconst(X) \\
	& + \alpha \cdot \left( (\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma)(\p{c}(\chz) + \beta k_2 \chz + \gamma) \cdot \p{z}(X)\right) \\
	& - \alpha \cdot \left( (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma)\beta \p{z}(\chz\omega) \cdot \p{S_{\sigma 3}}(X)\right) \\
	& + \alpha^2 \cdot \lag_1(\chz) \cdot \p{z}(X)
	\end{aligned}
	\]
	Output
	$\p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma
			2}}(\chz), \p{t}(\chz), \p{z}(\chz \omega), \p{r}(\chz).$
	
	\item[Message 5] Compute the opening challenge $v \in \FF_p$,
	$v = \ro(\tzkproof[0..4])$.  Compute the openings for the polynomial commitment
	scheme
	\hspace*{-2cm}\begin{align*}
	& \p{W_\chz}(X) = \frac{1}{X - \chz} \left(
	\begin{aligned}
	& \p{t_{lo}}(X) + \chz^\noofc \p{t_{mid}}(X) + \chz^{2 \noofc} \p{t_{hi}}(X) - \p{t}(\chz)
	+ v(\p{r}(X) - \p{r}(\chz)) 
	+ v^2 (\p{a}(X) - \p{a}(\chz))\\
	& + v^3 (\p{b}(X) - \p{b}(\chz))
	+ v^4 (\p{c}(X) - \p{c}(\chz))
	+ v^5 (\p{S_{\sigma 1}}(X) - \p{S_{\sigma 1}}(\chz)) \\
	& + v^6 (\p{S_{\sigma 2}}(X) - \p{S_{\sigma 2}}(\chz))
	\end{aligned}
	\right)\\
	& \p{W_{\chz \omega}}(X) = \infrac{(\p{z}(X) - \p{z}(\chz \omega))}{(X - \chz \omega)}
	\end{align*}
	Output $\gone{\p{W_{\chz}}(\chi), \p{W_{\chz \omega}}(\chi)}$.
\end{description}

\ncase{Plonk verifier $\verifier(\srs, \inp, \zkproof)$}\ \newline
The \plonk{} verifier works as follows
\begin{enumerate}
	\item Validate all obtained group elements.
	\item Validate all obtained field elements.
	\item Parse the instance as
	$\smallset{\wit_i}_{i = 1}^\instsize \gets \inp$.
	\item Compute challenges $\beta, \gamma, \alpha, \chz, v, u$ from the transcript.
	\item Compute zero polynomial evaluation
	$\p{Z_H} (\chz) =\chz^\noofc - 1$.
	\item Compute Lagrange polynomial evaluation
	$\lag_1 (\chz) = \frac{\chz^\noofc -1}{\noofc (\chz - 1)}$.
	\item Compute public input polynomial evaluation
	$\pubinppoly (\chz) = \sum_{i \in \range{1}{\instsize}} \wit_i
	\lag_i(\chz)$.
	\item Compute quotient polynomials evaluations
	\begin{multline*}
	\p{t} (\chz) =  \Big(
	\p{r} (\chz) + \pubinppoly(\chz) - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma) 
	(\p{c}(\chz) + \gamma)\p{z}(\chz \omega) \alpha - \lag_1 (\chz) \alpha^2
	\Big) / {\p{Z_H}(\chz)} \,.
	\end{multline*}
	\item Compute batched polynomial commitment
	$\gone{D} = v \gone{r} + u \gone {z}$ that is
	\begin{align*}
	\gone{D} & = v
	\left(
	\begin{aligned}
	& \p{a}(\chz)\p{b}(\chz) \cdot \gone{\selmulti} + \p{a}(\chz)  \gone{\selleft} + \p{b}  \gone{\selright} + \p{c}  \gone{\seloutput} + \\
	& + (	(\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma) (\p{c} + \beta k_2 \chz + \gamma) \alpha  + \lag_1(\chz) \alpha^2)  + \\
	% &   \\
	& - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz)
	+ \beta \p{S_{\sigma 2}}(\chz) + \gamma) \alpha \beta \p{z}(\chz
	\omega) \gone{\p{S_{\sigma 3}}(\chi)})
	\end{aligned}
	\right) + \\
	& + u \gone{\p{z}(\chi)}\,.
	\end{align*}
	\item Computes full batched polynomial commitment $\gone{F}$:
	\begin{align*}
	\gone{F} & = \left(\gone{\p{t_{lo}}(\chi)} + \chz^\noofc \gone{\p{t_{mid}}(\chi)} + \chz^{2 \noofc} \gone{\p{t_{hi}}(\chi)}\right) + u \gone{\p{z}(\chi)} + \\
	& + v
	\left(
	\begin{aligned}
	& \p{a}(\chz)\p{b}(\chz) \cdot \gone{\selmulti} + \p{a}(\chz)  \gone{\selleft} + \p{b}(\chz)   \gone{\selright} + \p{c}(\chz)  \gone{\seloutput} + \\
	& + (	(\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma) (\p{c}(\chz)  + \beta k_2 \chz + \gamma) \alpha  + \lag_1(\chz) \alpha^2)  + \\
	% &   \\
	& - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma) \alpha  \beta \p{z}(\chz \omega) \gone{\p{S_{\sigma 3}}(\chi)})
	\end{aligned}
	\right) \\
	& + v^2 \gone{\p{a}(\chi)} + v^3 \gone{\p{b}(\chi)} + v^4 \gone{\p{c}(\chi)} + v^5 \gone{\p{S_{\sigma 1}(\chi)}} + v^6 \gone{\p{S_{\sigma 2}}(\chi)}\,.
	\end{align*}
	\item Compute group-encoded batch evaluation $\gone{E}$
	\begin{align*}
	\gone{E}  = \frac{1}{\p{Z_H}(\chz)} & \gone{
		\begin{aligned}
		& \p{r}(\chz) + \pubinppoly(\chz) +  \alpha^2  \lag_1 (\chz) + \\
		& - \alpha \left( (\p{a}(\chz) + \beta \p{S_{\sigma 1}} (\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}} (\chz) + \gamma) (\p{c}(\chz) + \gamma) \p{z}(\chz \omega) \right)
		\end{aligned}
	}\\
	+ & \gone{v \p{r}(\chz) + v^2 \p{a}(\chz) + v^3 \p{b}(\chz) + v^4 \p{c}(\chz) + v^5 \p{S_{\sigma 1}}(\chz) + v^6 \p{S_{\sigma 2}}(\chz) + u \p{z}(\chz \omega) }\,.
	\end{align*}
	\item Check whether the verification
	% $\vereq_\zkproof(\chi)$
	equation holds
	\begin{multline}
	\label{eq:ver_eq} 
	\left( \gone{\p{W_{\chz}}(\chi)} + u \cdot \gone{\p{W_{\chz
				\omega}}(\chi)} \right) \bullet
	\gtwo{\chi} - \\
	\left( \chz \cdot \gone{\p{W_{\chz}}(\chi)} + u \chz \omega \cdot
	\gone{\p{W_{\chz \omega}}(\chi)} + \gone{F} - \gone{E} \right) \bullet
	\gtwo{1} = 0\,.
	\end{multline}
	The verification equation is a batched version of the verification equation
	from \cite{AC:KatZavGol10} which allows the verifier to check openings of
	multiple polynomials in two points (instead of checking an opening of a single
	polynomial at one point).
\end{enumerate}

\ncase{Plonk simulator $\simulator_\chi(\srs, \td= \chi, \inp)$}\ 
We describe the simulator in \cref{lem:plonk_tlzk}.

\subsection{Simulation extractability of $\plonk${}}
%Due to lack of space, we provide here only theorem statements and intuition for why they hold. Full proofs are given in \cref{sec:plonkse_proofs}.

\oursubsub{Unique Response Property}
\begin{lemma}
	\label{lem:plonkprot_ur}
	Let $\PCOMp$ be a polynomial commitment that is $\epsbind(\secpar)$-binding and has unique opening property with loss $\epsop (\secpar)$. Then $\plonkprotfs$ is $\ur{3}$ against algebraic adversaries, who makes up to $q$ random oracle queries, with security loss $\epsbinding (\secpar) + \epsop ( \secpar )$.
\end{lemma}
\paragraph{Intuition.} We show that an adversary who can break the $3$-unique response property of $\plonkprotfs$ can be either used to break the commitment scheme's evaluation binding or unique opening property. The former happens with the probability upper-bounded by $\epsbinding (\secpar)$, the latter with the probability upper bounded by $\epsop (\secpar)$. 

\begin{proof}
	Let $\adv$ be an algebraic adversary tasked to break the $\ur{3}$-ness of
	$\plonkprotfs$. We show that the first three prover's messages determine, along with 	the verifiers challenges, the rest of it. We denote by $\zkproof^0$ and $\zkproof^1$ the two proofs that the adversary outputs. To distinguish polynomials and commitments which an honest prover would send in the proof from the polynomials and commitments computed by the adversary we write the latter using indices $0$ and $1$ (two indices as we have two transcripts), e.g.~to describe the quotient polynomial provided by the adversary we write $\p{t}^0$ and $\p{t}^1$ instead of $\p{t}$ as in the description of the protocol.
	
	We note that since the unique response property requires from $\zkproof^{0}$ and $\zkproof^{1}$ that the first place they possibly differ is the $4$-th prover's message, then the challenge $\chz$, that is picked by the adversary after the $3$-rd message is the same in both transcripts. This challenge determines the evaluation point of polynomials $\p{a}(X), \p{b}(X), \p{c}(X), \p{t}(X), \p{z}(X)$ which commitments are already sent.
	
	In its fourth message, the prover provides evaluations of the aforementioned polynomials, along with evaluations of publicly known polynomials $
	\p{S_{\sigma 1}} (\chz), \p{S_{\sigma 2}} (\chz)$, and evaluation of a linearization polynomial $\p{r}(\chz)$.
	
	Note that the adversary can output two accepting proofs that differ on their fourth message only if it either manages to break evaluation binding of one of the opening, or provides an incorrect opening which is accepted due to a batching error. Since the commitment scheme is evaluation binding with security loss $\epsbinding (\secpar)$, %and the batched verification equation accepts an incorrect opening with probability at most $\infrac{q}{p}$, cf.~\cite{EPRINT:GabWilCio19}, 
	the adversary can make $\zkproof^{0}$ and $\zkproof^{1}$ differ on the fourth message with the same probability. % at most $8  \cdot \epsbinding (\secpar) + \infrac{q}{p}$. 
	
	Next, assume that the transcripts are the same up to the fourth message, but differ at the fifth. In that message, the adversary provides openings of the evaluations. Since the unique opening property, the adversary can open the valid evaluation of a polynomial to two different values with probability at most $\epsop (\secpar)$. (We note that for the KZG polynomial commitment scheme, as used in \cite{EPRINT:GabWilCio19}, $\epsop (\secpar) \leq \epsudlog (\secpar) + \infrac{q}{p}$, cf.~\cref{lem:pcomp_op}.)
	% , which is upper-bounded by $\epsudlog (\secpar) + \infrac{q}{p}$, cf.~\cref{lem:pcomp_op}.
	
	By the union bound, the adversary is able to break the unique response property with probability upper bounded by $\epsbinding (\secpar) + \epsop (\secpar)$.
	\qed
\end{proof}


\oursubsub{Rewinding-Based Knowledge Soundness}
\begin{lemma}
	\label{lem:plonkprot_ss}
	$\plonkprotfs$ is $(3, 3 \noofc + 6)$-rewinding-based knowledge sound against algebraic adversaries who make up to $q$ random oracle queries with security loss 
	\[
	\epscss(\secpar,\accProb, q) \leq \left(1 - \frac{\accProb - (q + 1) \left(\frac{3 \noofc + 5}{p} \right)}{1 - \frac{3 \noofc + 5}{p}}\right) + (3 \noofc + 6) \cdot \epsudlog (\secpar) %+ (3 \noofc + 6) \cdot \epsid (\secpar)
	\,,
	\]
	Here $\accProb$ is a probability that the adversary outputs an accepting proof, 
	%$\epsid(\secpar)$ is a soundness error of the ideal verifier for $\plonkprot$, 
	and $\epsudlog(\secpar)$ is security of $(\numberofconstrains + 5, 1)$-$\udlog$ 
	assumption.
\end{lemma}

\paragraph{Intuition.} We use Attema et al.~\cite[Proposition 2]{EPRINT:AttFehKlo21} to bound the probability that an algorithm $\tdv$ does not obtain a tree of accepting transcripts in an expected number of runs. This happens with probability at most
	\[
	1 - \frac{\accProb - (q + 1) \left(\frac{3 \noofc + 5}{p} \right)}{1 - \frac{3 \noofc + 5}{p}}
	\]
Then we analyze the case that one of the proofs in the tree $\tree$ outputted by $\tdv$ is not accepting by the ideal verifier. This discrepancy can be used to break an instance of an updatable dlog assumption which happens with probability at most $(3 \noofc + 6)  \cdot \epsudlog (\secpar)$. %Additionally, it may be impossible to extract the witness from a tree where each of the transcripts is accepting by the ideal verifier if the adversary broke soundness of the ideal verifier in one of the transcripts. That happens with probability at most $(3 \noofc + 6) \cdot \epsid (\secpar)$.

\begin{proof}
	Let $\adv^{\ro, \initU}(\secparam; r)$ be the adversary who outputs $(\inp, \zkproof)$ such that $\plonkprotfs.\verifier$ accepts the proof. Let $\tdv$ be a tree-building algorithm of \cref{lem:attema} that outputs a tree $\tree$, and let $\extcss$ be an extractor that given the tree output by $\tdv$ reveals the witness for $\inp$. The main idea of the proof is to show that an adversary who breaks rewinding-based knowledge soundness can be used to break a $\udlog$-problem instance. The proof goes by game hops. Note that since the tree branches after $\adv$'s $3$-rd message, the instance $\inp$, commitments $\gone{\p{a} (\chi), \p{b} (\chi), \p{c} (\chi), \p{z} (\chi), \p{t_{lo}} (\chi), \p{t_{mid}} (\chi), \p{t_{hi}} (\chi)}$, and challenges $\alpha, \beta, \gamma$ are the same in all the transcripts. Also, the tree branches after the third adversary's message where the challenge $\chz$ is presented, thus tree $\tree$ is built using different values of $\chz$.	We consider the following games.
	
	\ncase{Game 0} %
	In this game the adversary wins if it outputs a valid instance--proof pair $(\inp, \zkproof)$, and the extractor $\extcss$ does not manage to output a witness $\wit$ such that $\REL (\inp, \wit)$ holds.
	
	\ncase{Game 1} %
	In this game the environment aborts the game if the tree building algorithm $\tdv$ fails in building a tree of accepting transcripts $\tree$. 
	
	\ncase{Game 0 to Game 1} %
	By \cref{lem:attema} probability that Game 1 is aborted, while Game 0 is not, is at most 
	%\hamid{2.5}{Should this not be "1 minus the following"?}
	\[
	1 - \frac{\accProb - (q + 1) \left(\frac{3 \noofc + 5}{p} \right)} {1 - \frac{3 \noofc + 5}{p}} \,.
	\]
	
	\ncase{Game 2} %
	In this game the environment additionally aborts if at least one of its proofs in $\tree$ is not accepting by an ideal verifier.
	
	\ncase{Game 1 to Game 2} % 
	As usual, we show a reduction that breaks an instance of a $\udlog$ assumption when Game 2 is aborted, while Game 1 is not.
	
	Let $\rdvudlog$ be a reduction that gets as input an $(\noofc + 5, 1)$-$\udlog$ instance $\gone{1, \ldots, \chi^{\noofc + 5}}, \gtwo{\chi}$. Then it can update the instance to another one $\gone{1, \ldots, {\chi'}^{\noofc + 5}}, \gtwo{\chi'}$. Eventually, the reduction outputs $\chi'$.
	%
	The reduction $\rdvudlog$ proceeds as follows.
	First, it builds $\adv$'s SRS $\srs$ using the input $\udlog$ instance. Then it processes the adversary's update query by adding it to the list $\Qsrs$ and passing it to its own update oracle getting instance $\gone{1, \ldots, {\chi'}^{\noofc + 5}}, \gtwo{\chi'}$. The updated SRS $\srs'$ is then computed and given to $\adv$. $\rdvdulog$ also takes care of the random oracle queries made by $\adv$. It picks their answers honestly and write them in $\Qro$. The reduction then starts $\tdv(\srs, \adv, r, \Qro, \Qsrs)$.
	
	Let $(1, \tree)$ be the output returned by $\tdv$. Let $\inp$ be a relation proven in $\tree$.  Consider a transcript $\zkproof \in \tree$ such that $\vereq_{\inp, \zkproof}(X) \neq 0$, but $\vereq_{\inp, \zkproof}(\chi') = 0$. Since $\adv$ is algebraic, all group elements included in $\tree$ are extended by their representation as a combination of the input $\GRP_1$-elements. Hence, all coefficients of the verification equation polynomial $\vereq_{\inp, \zkproof}(X)$ are known. 
	Eventually, the reduction finds $\vereq_{\inp, \zkproof}(X)$ zero points and returns $\chi'$ which is one of them.
	
	Hence, the probability that the adversary wins in Game 2 but does not win in Game 1 is upper-bounded by $(3 \noofc + 6) \cdot \epsudlog (\secpar)$.
	
	\ncase{Conclusion}
	
	Note that the adversary can win in Game 2 only if $\tdv$ manages to produce a tree of accepting transcripts $\tree$, such that each of the transcripts in $\tree$ is accepting by an ideal verifier. Note that since $\tdv$ produces $(3 \noofc + 6)$ accepting transcripts for different challenges $\chz$, it obtains the same number of different evaluations of polynomials $\p{a} (X), \p{b} (X), \p{c} (X), \p{z} (X), \p{t} (X)$. Since all the transcripts are accepting by an idealised verifier, the equality between polynomial $\p{t} (X)$ and combination of polynomials $\p{a} (X), \p{b} (X), \p{c} (X), \p{z} (X)$ defined in prover's $3$-rd message description holds. Hence, $\p{a} (X), \p{b} (X), \p{c} (X)$ encodes the valid witness for the proven statement. $\extcss$ can recreate polynomials' coefficients by interpolation and reveal the witness given $(3 \noofc + 6)$ evaluations. 
	% Thus, the probability that extraction fails in that case is upper-bounded by $(3 \noofc + 6) \cdot \epsid(\secpar)$.
	
	
	Hence, the probability that the adversary wins in Game 0 is upper-bounded by 
	\[
	\epscss(\secpar,\accProb, q) \leq \left(1 - \frac{\accProb - (q + 1) \left(\frac{3 \noofc + 5}{p} \right)}{1 - \frac{3 \noofc + 5}{p}}\right) + (3 \noofc + 6) \cdot \epsudlog (\secpar)\,. 
	\]
	\qed
\end{proof}


\oursubsub{Trapdoor-Less Zero-Knowledge of Plonk}
\michals{16.06}{PKC proof below, check}
\begin{lemma}
	$\plonk$ is trapdoor-less zero-knowledge.\footnote{The simulator works as a simulator for proofs that are zero-knowledge in the standard model. However, we do not say that $\plonk$ is HVZK in the standard model as proof of that \emph{requires} the CRS simulator.} More precisely, assume that $\plonk$'s CRS simulator $\simulator_\chi$ produces a proof that is at most $\epszk$ far from a real proof, and $(\pR, \pS, \pT, \pf)$-uber assumption for $\pR, \pS, \pT, \pf$ as defined in \cref{eq:uber} is $\epsuber$-secure. Then for any $\ppt$ adversary $\adv$ its advantage in telling a proof produced by $\simulator$ from a real proof is upper-bounded by $\epszk + \epsuber$.
	\end{lemma}
	\begin{proof}
	The proof goes by game-hoping. The environment that controls the games
	provides the adversary with a CRS $\crs$, then the adversary outputs an
	instance--witness pair $(\inp, \wit)$ and, depending on the game, is
	provided with either real or simulated proof for it. In the end of the game
	the adversary outputs either $0$ if it believes that the proof it saw was
	provided by the simulator and $1$ in the other case.
	
	\ngame{0} In this game $\adv(\REL, \crs)$ picks an instance--witness
	pair $(\inp, \wit)$ and gets a real proof $\zkproof$ for it.
	
	\ngame{1} In this game for $\adv(\REL, \crs)$ picks an instance--witness
	pair $(\inp, \wit)$ and gets a proof $\zkproof$ that is simulated by a simulator
	$\simulator_\chi$ that utilises for the simulation the CRS trapdoor and
	proceeds as follows.
	In the first round the simulator $\simulator_\chi$ picks randomisers $b_1, \ldots b_9$, sets
	$\wit_i$, for $i \in \range{1}{3 \numberofconstrains}$, computes polynomials
	$\pa(X), \pb(X), \pc(X)$ and outputs $\gone{\pa(\chi), \pb(\chi), \pc(\chi)}$. 
	Then it picks Round 1 challenge $\beta, \gamma$ honestly.
	
	In the second round $\simulator_\chi$ computes the polynomial $\pz(X)$ and
	outputs $\gone{\pz(\chi)}$. Then it picks randomly Round 2 challenge
	$\alpha$.
	
	In the third round the simulator computes polynomial $\pt(X)$ and evaluates it
	at $\chi$, then outputs $\gone{\ptlo(\chi), \ptmid(\chi),
	\pthi(\chi)}$. Note that this evaluation is possible only since
	$\simulator_\chi$ knows the trapdoor.
	
	In the last two rounds the simulator proceeds as an honest prover would
	proceed and picks corresponding challenges at random as an honest verifier
	would.
	
	\ncase{$\game{0} \mapsto \game{1}$} 
	Since $\plonk$ is zero-knowledge, probability that $\adv$ outputs a
	different bit in both games is negligible. Hence
	\[
		\abs{\prob{\game{0}} - \prob{\game{1}}} \leq \epszk.
	\]
	
	\ngame{2} In this game $\adv(\REL, \crs)$ picks an
	instance--witness pair $(\inp, \wit)$ and gets a proof $\zkproof$ simulated
	by the simulator $\simulator$ which proceeds as follows:
	
	Since the simulator $\simulator$ does not know a witness $\wit$ for the
	proven statement $\inp$, it cannot compute the output of Round 1 accordingly
	to the protocol. Instead, it picks randomly both the randomisers $b_1,
	\ldots, b_6$ and sets $\wit_i = 0$ for $i \in
	\range{1}{3\numberofconstrains}$. Then $\simulator$ outputs $\gone{\p{a}(\chi),
	\p{b}(\chi), \p{c}(\chi)}$.  For the first round challenge, the simulator
	picks permutation argument challenges $\beta, \gamma$ randomly.
	
	In the second round, the simulator cannot the simulator computes $\p{z}$
	from the newly picked randomisers $b_7, b_8, b_9$ and coefficients of
	polynomials $\p{a}, \p{b}, \p{c}$. Then it evaluates $\p{z}$ honestly and
	outputs $\gone{\p{z}(\chi)}$.  Challenge $\alpha$ that should be sent by the
	verifier after Round 2 is picked by the simulator at random.
	
	The next round starts by the simulator picking at random a challenge $\chz$,
	which in the real proof comes as a challenge from the verifier sent after
	Round 3.  Then $\simulator$ computes evaluations \(\p{a}(\chz), \p{b}(\chz),
		\p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma 2}}(\chz),
	\pubinppoly(\chz), \lag_1(\chz), \p{Z_H}(\chz),\allowbreak
	\p{z}(\chz\omega)\) and computes $\p{t}(X)$ honestly. Since for a random
	$\p{a}, \p{b}, \p{c},
	\p{z}$ the constraint system is (with overwhelming probability) not
	satisfied and the constraints-related polynomials are not divisible by
	$\p{Z_H}$,
	$\p{t}(X)$ is a rational function, not a polynomial. Then, the simulator
	evaluates $\p{t}(X)$ at $\chz$ and picks randomly a
	degree-$(\numberofconstrains + 2)$ polynomial $\p{\tilde{t}}(X)$ such that
	$\p{t}(\chz) = \p{\tilde{t}}(\chz)$ and publishes a commitment
	$\gone{\p{\tilde{t}}(\chi)}$.  After this round the simulator outputs $\chz$
	as a challenge.
	
	In the next round, the simulator computes polynomial $\p{r}(X)$ as an honest
	prover would, cf.~\cref{sec:plonk_explained} and evaluates $\p{r}(X)$ at $\chz$. 
	
	The rest of the evaluations are already computed, thus 
	$\simulator$ simply outputs 
	\[
		\p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma 2}}(\chz), \p{t}(\chz), \p{z}(\chz \omega)\,.
	\]
	After that it picks randomly the challenge $v$, proceeds in the last round as
	an honest prover would proceed and outputs the final challenge, $u$, by
	picking it at random as well.
	
	\ncase{$\game{1} \mapsto \game{2}$}
	We now describe the reduction $\rdv$ which relies on the $(\pR, \pS, \pT,
	\pf)$-uber assumption where $\pR, \pS, \pT, \pf$ are polynomials over
	variables $\vB = B_1, \ldots B_9$ and are defined as follows.
	Let $E = \smallset{\smallset{1, 2}, \smallset{3, 4}, \smallset{5, 6},
	\smallset{7, 8, 9}}$.
	Let 
	\begin{align}
	\label{eq:uber}
	\pR(\vB) & = \smallset{B_i \mid i \in A,\ A \in E} \cup \smallset{B_i B_j \mid i \in
	A, j \in B,\ A \neq B,\ A, B \in E} \cup \\ 
			& \smallset{B_i B_j B_k \mid i \in A,\ j \in
	B,\ k \in C,\ A \neq B \neq C \neq A,\ A, B, C \in E} \cup \notag \\
		& \smallset{B_i B_j B_k B_l \mid i \in A,\ j \in B,\ k \in C,\ l \in D,\
			A, B, C, D \text{ all different and in } E} \notag \\
		& \setminus \smallset{B_1
	B_3 B_5 B_7}\,,\notag \\
	\pS(\vB) & = \emptyset \notag\,, \\
	\pT(\vB) & = \emptyset \notag\,, \\
	\pf(\vB) & = B_1 B_3 B_5 B_7 \notag\,.
	\end{align}
	That is, the elements of $\pR$ are all singletons, pairs and triplets of $B_i$
	variables that occur in polynomial $\pt(\vB)$ except the
	challenge element $\pf(\vB) = B_1
	B_3 B_5 B_7$.
	Variables $\vB$ are evaluated to randomly picked $\vb = b_1, \ldots
	b_9$.
	
	The reduction $\rdv$ learns $\gone{\pR}$ and challenge $\gone{w}$ where $w$ is
	either $\pf(\vb) = b_1 b_3 b_5 b_7$ or a random value.
	Then it picks $\chi$, $\chz$ and computes the CRS $\crs$ from $\chi$ 
	Elements  $b_i$ are
	interpreted as polynomials in $X$ that are evaluated at $\chi$, i.e. $b_i =
	b_i(\chi)$
	Next, $\rdv$ sets 
	\[ \gone{\p{\tb}_i}(X) =
	(X - \chz)(X - \ochz) \gone{b_i}(X) + \xi_i (X - \chz) \gone{1} +
	\zeta_i (X - \ochz) \gone{1}, % \text{ for } i \in % \range{1}{9}, u_1
	\sample \FF_p 
	\] 
	for $i \in \range{1}{9}$ and $\xi_i, \zeta_i \sample \FF_p$. Denote by $\tb_i$
	evaluations of $\p{\tb}_i$ at $\chi$.
	The reduction computes all $\gone{\tb_i \tb_j}, \gone{\tb_i \tb_j \tb_k},
	\gone{\tb_i \tb_j \tb_k \tb_l}$ such that
	$\gone{B_i B_j, B_i B_j B_k B_l} \in \pR$.
	This is possible since $\rdv$ knows all singletons $\gone{b_1, \ldots,
	b_9}$ and pairs $\gone{b_i b_j} \in \pR$ which can be used to compute all
	required pairs $\gone{\tb_i \tb_j}$: 
	\begin{align*}
	\gone{\tb_i \tb_j} 
	& = ((\chi - \chz)(\chi - \ochz)\gone{b_i} + \xi_i (\chi - \chz)\gone{1} +
	\zeta_i (\chi - \ochz) \gone{1}) 
	\cdot \\
	 & ((\chi - \chz)(\chi - \ochz)\gone{b_j} + \xi_j (\chi - \chz)\gone{1} +
	\zeta_j (\chi - \ochz) \gone{1}) = \\
	 & ((\chi - \chz)(\chi - \ochz))^2 \gone{b_i b_j} +  ((\chi - \chz)(\chi -
	 \ochz)\gone{b_i} (\xi_j (\chi - \chz) \gone{1} + \zeta_j (\chi - \ochz)
	 \gone{1}) + \\
	 & ((\chi - \chz)(\chi -
	 \ochz)\gone{b_j} (\xi_i (\chi - \chz) \gone{1} + \zeta_i (\chi - \ochz)
	 \gone{1}) + \psi,
	\end{align*}
	where $\psi$ compounds of $\xi_i, \xi_j, \zeta_i, \zeta_j, \chz, \ochz, \chi$ which
	are all known by $\rdv$ and no $b_i$ nor $b_j$.
	Analogously for the triplets and quadruplets. 
	
	For the challenge $\gone{w}$ $\rdv$ sets $\gone{\tw} = \gone{\tb_1 \tb_3
	\tb_5 \tb_7}$, where $\gone{b_1 b_3 b_5 b_7}$ is substituted by $\gone{w}$.
	Next it runs the adversary $\adv(\REL, \crs)$ and obtains from $\adv$ an
	instance--witness pair $(\inp, \wit)$.  $\rdv$ now prepares a simulated proof.
	
	\begin{description} 
	\item[Round 1] $\rdv$ computes $\gone{\pa(\chi)}$ using as
	randomisers $\gone{\tb_1}, \gone{\tb_2}$ and setting $\wit_i = 0$, for $i
	\in \range{1}{3 \numberofconstrains}$. Similarly it computes
	$\gone{\pb(\chi)}, \gone{\pc(\chi)}$.  $\rdv$ publishes the obtained values
	and picks a Round 1 challenge $\beta, \gamma$ at random.  
	\item[Round 2]
	$\rdv$ computes $\gone{\pz(\chi)}$ using $\tb_7, \tb_8, \tb_9$ and publishes
	it. Then it picks randomly the challenge $\alpha$.  
	\item[Round 3] The
	reduction computes $\gone{\pt(\chi)}$ using $\tw$ as it was equal $\tb_1
	\tb_3 \tb_5 \tb_7$. That is, if $w = b_1 b_3 b_5 b_7$ then $\pt(\chi)$ is as
	computed by the simulator $\simulator_\chi$, otherwise, if $w$ is random
	then $\pt(\chi)$ is random as well, thus it is computed as $\simulator$
	would compute. The reduction computes and outputs $\gone{\ptlo(\chi),
	\ptmid(\chi), \pthi(\chi)}$ such that $\pt(X) = \ptlo(X) +
	X^\numberofconstrains \ptmid(X) + X^{2\numberofconstrains} \pthi(X)$.
	Eventually, $\rdv$ outputs $\chz$.  
	\item[Round 4] The reduction outputs
	$\pa(\chz), \pb(\chz), \pc(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma 2}
		(\chz)}, \pt(\chz), \pz(\ochz)$.  For the sake of concreteness, denote by
		$S = \smallset{\pa, \pb, \pc, \pt, \pz}$. Although for a polynomial $\p{p}
		\in S$, reduction $\rdv$ does not know $\p{p}(\chi)$ or even do not know
		all the coefficients of $\p{p}$, the polynomials in $S$ was computed such
		that the reduction always knows their evaluation at $\chz$ and $\ochz$.
	\item[Round 5] $\rdv$ computes the openings of the polynomial commitments
	assuring that evaluations at $\chz$ it provided were computed honestly.
	\end{description} Is the adversary $\adv$'s output distribution differ in
	Game $\game{1}$ and $\game{2}$ then the reduction uses it to distinguish
	between $w = b_1 b_3 b_5 b_7$ and $w$ being random, thus \(
	\abs{\prob{\game{1}} - \prob{\game{2}}} \leq \epsuber.  \) Eventually, \(
	\abs{\prob{\game{0}} - \prob{\game{2}}} \leq \epszk + \epsuber.  \) \qed
	\end{proof}
\michals{9.06}{Got back to the uber assumption}
\COMMENT{
\begin{lemma}
	\label{lem:plonk_tlzk}
	$\plonkprotfs$ is 3-programmable trapdoor-less zero-knowledge.
\end{lemma}

\paragraph{Intuition.} The simulator, that does not know the SRS trapdoor can make a simulated proof by programming the random oracle. It proceeds as follows. It picks a random witness and behaves as an honest prover up to the point when a commitment to the polynomial $\p{t}(X)$ is sent. Since the simulator picked a random witness and $\p{t}(X)$ is a polynomial only (modulo some negligible function) when the witness is correct, it cannot compute commitment to $\p{t}(X)$ as it is a rational function. However, the simulator can pick a random challenge $\chz$ and a polynomial $\p{\tilde{t}}(X)$ such that $\p{t} (\chz)  = \p{\tilde{t}} (\chz)$. Then the simulator continues behaving as an honest prover. We argue that such a simulated proof is indistinguishable from a real one.

\begin{proof}
	As noted in \cref{def:upd-scheme}, subvertible zero-knowledge implies updatable zero-knowledge. Hence, here we show that Plonk is TLZK even against adversaries who picks
	the SRS on its own.
	
	The adversary $\adv(\secparam)$ picks an SRS $\srs$ and instance--witness pair
	$(\inp, \wit)$ and gets a proof $\zkproof$ simulated by the simulator
	$\simulator$ which proceeds as follows.
	
	For its $1$-st message the simulator  picks randomly both the randomizers $b_1, \ldots, b_6$ and
	sets $\wit_i = 0$ for $i \in \range{1}{3\noofc}$. Then $\simulator$
	outputs $\gone{\p{a}(\chi), \p{b}(\chi), \p{c}(\chi)}$. For the first
	challenge, the simulator picks permutation argument challenges $\beta, \gamma$
	randomly.
	
	For its $2$-nd message, the simulator computes $\p{z}(X)$ from
	the newly picked randomizers $b_7, b_8, b_9$ and coefficients of polynomials
	$\p{a}(X), \p{b}(X), \p{c}(X)$. Then it evaluates $\p{z}(X)$ honestly and outputs
	$\gone{\p{z}(\chi)}$. Challenge $\alpha$ that should be sent by the verifier
	after the simulator's $2$ message is picked by the simulator at random.
	
	In its $3$-rd message the simulator starts by picking at random a challenge $\chz$, which
	in the real proof comes as a challenge from the verifier sent \emph{after} the prover
	sends its $3$-rd message. Then $\simulator$ computes evaluations
	\(\p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma
			2}}(\chz), \pubinppoly(\chz), \lag_1(\chz), \p{Z_H}(\chz),\allowbreak
	\p{z}(\chz\omega)\) and computes $\p{t}(X)$ honestly. Since for a random
	$\p{a}(X), \p{b}(X), \p{c}(X), \p{z}(X)$ the constraint system is (with
	overwhelming probability) not satisfied and the constraints-related polynomials
	are not divisible by $\p{Z_H}(X)$, hence $\p{t}(X)$ is a rational function
	rather than a polynomial. Then, the simulator evaluates $\p{t}(X)$ at $\chz$ and
	picks randomly a degree-$(3 \noofc + 15)$ polynomial $\p{\tilde{t}}(X)$ such that
	$\p{t}(\chz) = \p{\tilde{t}}(\chz)$ and publishes a commitment
	$\gone{\p{\tilde{t}_{lo}}(\chi), \p{\tilde{t}_{mid}}(\chi),
		\p{\tilde{t}_{hi}}(\chi)}$. After that the simulator outputs $\chz$ as a
	challenge.
	
	For the next message, the simulator computes polynomial $\p{r}(X)$ as an honest
	prover would, cf.~\cref{sec:plonk_explained} and evaluates $\p{r}(X)$ at $\chz$.
	
	The rest of the evaluations are already computed, thus $\simulator$ simply outputs
	\( \p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma
			2}}(\chz), \p{t}(\chz), \p{z}(\chz \omega)\,.  \) After that it picks randomly
	the challenge $v$, and prepares the the last message as an honest prover
	would. Eventually, $\simulator$ and outputs the final challenge, $u$, by picking it
	at random as well.
	
	We argue about zero-knowledge as usual. The property holds since the polynomials that has witness elements at their coefficients are randomized by at least two randomizers and are evaluated at at most two points; and the simulator computes all polynomials as an honest prover would.
	\qed
\end{proof}
}

\subsection*{Simulation Extractability of~$\plonkprotfs$}
Since \cref{lem:plonkprot_ur,lem:plonkprot_ss,lem:plonk_tlzk} hold, $\plonkprot$ is $\ur{3}$,
rewinding-based knowledge sound and trapdoor-less zero-knowledge. We now make use of \cref{thm:se} and show that
$\plonkprot_\fs$ is simulation-extractable as defined in \cref{def:updsimext}.

\begin{corollary}[Simulation extractability of $\plonkprot_\fs$]
	\label{thm:plonkprotfs_se}
	$\plonkprotfs$ is \emph{updatable simulation-extractable} against any $\ppt$ adversary $\advse$ who makes up to $q$ random oracle queries and returns an accepting proof with probability at least $\accProb$ with extraction failure probability 
	\[
	\epsse(\secpar, \accProb, q) \leq \left(1 - \frac{\accProb - \epsur (\secpar) - (q + 1) \epserr (\secpar)} {1 - \epserr (\secpar)}\right) + (3 \noofc + 6) \cdot \epsudlog (\secpar)\COMMENT{ + (3 \noofc + 6) \cdot \epsid (\secpar)},
	\]
	where $\epserr (\secpar) = \frac{3 \noofc + 5}{p}$, $\epsur (\secpar) \leq \epsbind (\secpar) + \epsop (\secpar)$, $p$ is the size of the field, and $\noofc$ is the number of constrains in the circuit. 
\end{corollary}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

